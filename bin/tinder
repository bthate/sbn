#!/usr/bin/env python3
# This file is placed in the Public Domain.


import importlib.util
import os
import queue
import shutil
import sys
import threading
import time


sys.path.insert(0, os.getcwd())


from sbn.defines import Config, Default, Message, Output, Workdir
from sbn.defines import command, elapsed, fmt, launch, package, parse
from sbn.defines import scan, scanner, skel, spl 


import sbn.modules as MODS


Config.debug = True
Config.gets = Default()
Config.ignore = "man,mbx,rst,udp,web"
Config.init = ""
Config.level = "info"
Config.name = "sbn"
Config.opts = ""
Config.path = package(MODS)
Config.sets = Default()
Config.txt = " ".join(sys.argv[1:])
Config.version = 150


Workdir.wdr = ".test"


events = queue.Queue()


class CLI(Output):

    def __init__(self):
        Output.__init__(self)
        self.register("command", command)

    def raw(self, txt):
        if "v" in Config.opts:
            print(txt)


class Pool:

    clients = []
    lock = threading.RLock()
    nrcpu = 1
    nrlast = 0

    @staticmethod
    def add(client):
        Pool.clients.append(client)

    @staticmethod
    def init(clz, nr):
        Pool.nrcpu = nr
        for _x in range(Pool.nrcpu):
            clt = clz()
            clt.start()
            Pool.add(clt)

    @staticmethod
    def put(event):
        with Pool.lock:
            if Pool.nrlast >= Pool.nrcpu-1:
                Pool.nrlast = 0
            clt = Pool.clients[Pool.nrlast]
            clt.put(event)
            Pool.nrlast += 1


class Mods:

    dirs = {}
    modules = {}


def configure():
    dirs(f"{Config.name}.modules", Config.path)


def dirs(name: str, path):
    "add module directory."
    Mods.dirs[name] = path


def importer(name, pth=""):
    "import module by path."
    if pth and os.path.exists(pth):
        spec = importlib.util.spec_from_file_location(name, pth)
    else:
        spec = importlib.util.find_spec(name)
    if not spec or not spec.loader:
        return None
    mod = importlib.util.module_from_spec(spec)
    if not mod:
        return None
    Mods.modules[name] = mod
    spec.loader.exec_module(mod)
    return mod


def getmod(name):
    "import module by name." 
    if name in spl(Config.ignore):
        return None
    if name in Mods.modules:
        return Mods.modules[name]
    mname = ""
    pth = ""
    for packname, path in Mods.dirs.items():
        modpath = os.path.join(path, name + ".py")
        if os.path.exists(modpath):
            pth = modpath
            mname = f"{packname}.{name}"
            break
    return importer(mname, pth)


def mods(names):
    "list of named modules."
    return [
        getmod(x) for x in sorted(spl(names))
        if x not in spl(Config.ignore)
        or x in spl(Config.sets.init)
    ]


def modules():
    "comma seperated list of available modules."
    mods = []
    for name, path in Mods.dirs.items():
        if name in spl(Config.ignore):
            continue
        if not os.path.exists(path):
            continue
        mods.extend([
            x[:-3] for x in os.listdir(path)
            if x.endswith(".py") and not x.startswith("__") and x not in spl(Config.ignore)
        ])
    return ",".join(sorted(mods))


def banner(name, version):
    tme = time.ctime(time.time()).replace("  ", " ")
    print(f"{name.upper()} {version} since {tme} ({Config.level})")
    sys.stdout.flush()


def check(text):
    args = sys.argv[1:]
    for arg in args:
        if not arg.startswith("-"):
            continue
        for char in text:
            if char in arg:
                return True
    return False


def consume():
    while True:
        try:
            event = events.get()
            event.wait()
            events.task_done()
        except (KeyboardInterrupt, EOFError):
            os._exit(0)


def payload(todo):
    for cmd, example in todo.items():
        for ex in example:
            evt = Message()
            evt.text = f"{cmd} {ex}"
            evt.kind = "command"
            Pool.put(evt)
            events.put(evt)


def scanner(names=None):
    "scan named modules for commands."
    if names is None:
        names = modules()
    mods = []
    for name in spl(names):
        module = getmod(name)
        if not module:
            continue
        scan(module)
    return mods


examples = {
    "cmd": [""],
    "dis": [""],
    "dne": ["", "bla"],
    "dpl": ["hnrss title,url", ""],
    "flt": [""],
    "fnd": ["", "log", "rss", "config", "todo"],
    "man": [""],
    "mod": [""],
    "mre": [""],
    "nme": ["", "hnrss hackernews"],
    "now": [""],
    "pwd": ["", "bla mekker"],
    "req": [""],
    "res": ["", "hnrss"],
    "srv": [""],
    "thr": [""],
    "upt": [""]
}

pre = {
    "cfg": ["", "nick=mekker"],
    "imp": ["", "testing/feeds.opml"],
    "log": ["", "log add"],
    "rss": ["", "http://hnrss.org/newest"],
    "tdo": ["", "todo add"]
}

post = {
    "dbg": [""],
    "dne": ["", "mekker"],
    "exp": [""],
    "rem": ["", "hnrss"]
}



def main():
    if os.path.exists(Workdir.wdr):
        shutil.rmtree(Workdir.wdr)
    skel()
    parse(Config, " ".join(sys.argv[1:]))
    configure()
    scanner()
    if "v" in Config.opts:
        banner(Config.name, Config.version)
    if "z" in Config.opts:
        Pool.init(CLI, os.cpu_count())
    else:
        Pool.init(CLI, 1)
    starttime = time.time()
    thrs = []
    nrs = Config.index or 1
    for _x in range(nrs):
        thrs.append(launch(payload, pre))
    for thr in thrs:
        thr.join()
    for _x in range(nrs):
        thrs.append(launch(payload, examples))
    for thr in thrs:
        thr.join()
    for _x in range(nrs):
        thrs.append(launch(payload, post))
    for thr in thrs:
        thr.join()
    launch(consume)
    nrevents = events.qsize()
    try:
        events.join()
    except (KeyboardInterrupt, EOFError):
        os._exit(0)
    endtime = time.time()
    lap = elapsed(endtime-starttime)
    percall = (endtime-starttime)/nrevents
    nrs = events.qsize()
    if "v" in Config.opts:
        print(f"{fmt(Config)}")
        print(f"{nrs} events left.")
        print(f"total: {lap} nrs: {nrevents} call: %.6fs" % percall)
    os._exit(0)


if __name__ == "__main__":
    main()
